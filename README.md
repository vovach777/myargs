# myargs
simple arguments parcer

# Мотивация
Для простых и быстрых эксеприментов потребовались простые решения для парсинга аргументов.
Я попробовал популярные решения и они оказались тяжелыми замысловатыми и перегруженными.
Я решил потратить час времени и написать свой класс парсера аргументов, которые делает только то что мне нужно.

# Итог
Класс описан файле хедера. Достаточно его подключить и пользоваться.
Никаких сопоставлений и проверок! Используй сразу то что предложить пользователь.
## Умеет
### одно-символьные параметры. префикс -
-a -b -c -d -?
у них может быть значение. и есть только один способ как его задать: непосредственно за символом аргумента.
-a1 -b2 -c"строка"  -d-1 -I/path
### много-символьные параметры. префикс --
--alpha --beta --help
у них может быть значение. и есть только один способ как его задать: после символа "=".
--alpha=1 --bata=2 --help=compact -incluide-dir=/path

### без префикса
это называется команда или просто аргумент.

## Не умеет
получать значения аргументов их следуюего аргемента. Этот свособ вносит неопреленность и резонно его отменить вовсе в пользу простоты и строгости.

# Развитие
Нужна валидация. Нужен хелп основанный на валидации. Это будет полезно и удобно для реальных программ командной строки.

# Как пользоваться

```c++
#include <iostream>
#include "myargs.hpp"

int main(int argc, char** argv)
{
   myargs::Args args(argc,argv);

   std::cout << "cmd_nb:" << args.cmd_nb << std::endl;
   //все аргументы и опции
   //аргументы - это параметры без префикс
   //опции - это параметры с префиксом
   for (auto & kv : args)
   {
      std::cout << kv.first << " : " << kv.second << std::endl;
   }
   // первый аргумент (команда)
   std::cout << args[0] << std::endl;
    // второй аргемнт если есть.
   std::cout <<  (args.cmd_nb > 1 ? args[0] : "none" ) << std::endl;
   //опция integer -a  если нет то 0
   std::cout << args.get("a") << std::endl;
   //опция -a если нет то 555
   std::cout << args.get<555>("a") << std::endl;
   //опция -b взять и ограничить диаппазон
   std::cout << args.get<1,-5,5>("b") <<  (args.has("b") ? " (by user)" : " (default value is 1)"  )  << std::endl;

   //так получаем строку и задаем строку по умолчанию
   std::cout << args.get("I","/path") << std::endl;
   std::cout << args.get("include-dir","/path/to/dir") << std::endl;
   //прямой доступ unordered_map параметров
   std::cout << args.m.contains("f") << std::endl;

}
```

вывод

```bush
>testargs -I/root -a777 -b1000 --include-dir=/usr/local
cmd_nb:1
include-dir : /usr/local
b : 1000
a : 777
I : /root
%0 : testargs.exe
testargs.exe
none
777
777
5 (by user)
/root
/usr/local
0
```
